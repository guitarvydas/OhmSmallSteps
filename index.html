<!doctype html>
<html>
  <head>
    <title>ohm/js in small steps</title>
    <meta charset=utf-8>
    <script src="/Users/tarvydas/projects/ohm/examples/lib.js"></script>
    <script src="/Users/tarvydas/projects/ohm/dist/ohm.js"></script>
    <script type="text/test-hold">
      (#t #f)
    </script>
    
    <script type="text/test-hold">
      ( #t #f . #t)
    </script>
    
    <script type="text/test-hold">
      ( . #t)
    </script>
    
    <script type="text/test-hold">
      asymbol
    </script>
    
    <script type="text/test-hold">
      (asymbol)
    </script>

    <script type="text/test-hold">
      (asymbol1 asymbol2)
    </script>

    <script type="text/test-hold">
      (define asymbol10)
    </script>

    <script type="text/test-hold">
      (define asymbol11 asymbol12)
    </script>

    <script type="text/test-hold">
      (define (asymbol13 asymbol14))
    </script>

    <script type="text/test-hold">
      (define (asymbol15 asymbol16) 5)
    </script>

    <script type="text/test-hold">
      (define (x15 x16) x17)
    </script>

    <script type="text/test-hold">
      (define (x18 x19) (x20))
    </script>

    <script type="text/test-hold">
      (asymbol1a asymbol2a)
      (asymbol3 asymbol4)
    </script>

    <script type="text/test-hold">
      (prove5 '() goals db empty 1)
    </script>

    <script type="text/test-hold">
      (define (funNoFormals) 1)
    </script>

    <script type="text/test-hold">
      'asymbol5
    </script>

    <script type="text/test-hold">
      ('(asymbol6 asymbol7))
    </script>

    <script type="text/test-hold">
      `a
    </script>

    <script type="text/test-hold">
      `,b
    </script>

    <script type="text/test-hold">
      `(c)
    </script>
    <script type="text/test-hold">
      `(d e f)
    </script>
    <script type="text/test-hold">
      `(g ,h i)
    </script>

    <script type="text/test-hold">
(define (unify1 x y e)
  (let ((x (value x e))
        (y (value y e)))
    (cond
      ((eq? x y) e))
))
    </script>

    <script type="text/test-hold">
(define (unify2 x y e)
  (let ((x (value x e))
        (y (value y e)))
    (cond
      ((eq? x y) e)
      ((var? x) (bind x y e))
      ((var? y) (bind y x e))
      ((or (not (pair? x))
           (not (pair? y))) #f)
      (else
        (let ((e* (unify (car x) (car y) e)))
          (and e* (unify (cdr x) (cdr y) e*)))))))
    </script>

    <script type="text/test">
(define (prove6 l g r e n c)
  (cond
    ((null? g)
      (print-frame e)
      (back6 l g r e n c))
    ((eq? '! (car g))
      (clear_r c)
      (prove6 c (cdr g) r e n c))
    ((eq? 'r! (car g))
      (prove6 l (cddr g) r e n (cadr g)))
    ((null? r)
      (if (null? l)
          #t
          (back6 l g r e n c)))
    (else
      (let* ((a  (copy (car r) n))
             (e* (unify (car a) (car g) e)))
        (if e*
            (prove6 (link l g r e n c)
                    (append (cdr a) `(r! ,l) (cdr g))
                    db
                    e*
                    (+ 1 n)
                    l)
            (back6 l g r e n c))))))
    </script>




    <script type="text/test-prolog">
(define (try g r e n)
  (if (null? r)
      #f
      (let* ((a  (copy (car r) (list n)))
             (ne (unify (car g) (car a) e)))
        (if ne
            (prove3 (append (cdr a) (cdr g)) ne (+ 1 n)))
        (try g (cdr r) e n))))

(define (prove3 g e n)
  (cond ((null? g)
          (print-frame e))
        (else
          (try g db e n))))


(define link list)
(define L_l car)
(define L_g cadr)
(define L_r caddr)
(define L_e cadddr)
(define (L_n x) (car (cddddr x)))


(define (back5 l g r e n)
  (if (and (pair? g)
           (pair? r))
      (prove5 l g (cdr r) e n)
      (prove5 (L_l l)
              (L_g l)
              (cdr (L_r l))
              (L_e l)
              (L_n l))))


(define (prove5 l g r e n)
  (cond
    ((null? g)
      (print-frame e)
      (back5 l g r e n))
    ((null? r)
      (if (null? l)
          #t
          (back5 l g r e n)))
    (else
      (let* ((a  (copy (car r) n))
             (e* (unify (car a) (car g) e)))
        (if e*
            (prove5 (link l g r e n)
                    (append (cdr a) (cdr g))
                    db
                    e*
                    (+ 1 n))
            (back5 l g r e n))))))


(define (L_c x) (cadr (cddddr x)))


(define (clear_r x)
  (set-car! (cddr x) '(())))


(define (back6 l g r e n c)
  (cond
    ((and (pair? g)
          (pair? r))
      (prove6 l g (cdr r) e n c))
    ((pair? l)
      (prove6 (L_l l)
              (L_g l)
              (cdr (L_r l))
              (L_e l)
              (L_n l)
              (L_c l)))))


(define (prove6 l g r e n c)
  (cond
    ((null? g)
      (print-frame e)
      (back6 l g r e n c))
    ((eq? '! (car g))
      (clear_r c)
      (prove6 c (cdr g) r e n c))
    ((eq? 'r! (car g))
      (prove6 l (cddr g) r e n (cadr g)))
    ((null? r)
      (if (null? l)
          #t
          (back6 l g r e n c)))
    (else
      (let* ((a  (copy (car r) n))
             (e* (unify (car a) (car g) e)))
        (if e*
            (prove6 (link l g r e n c)
                    (append (cdr a) `(r! ,l) (cdr g))
                    db
                    e*
                    (+ 1 n)
                    l)
            (back6 l g r e n c))))))


(define empty '((bottom)))

(define var '?)
(define name cadr)
(define time cddr)

(define (var? x)
  (and (pair? x)
       (eq? var (car x))))

(define (lookup v e)
  (let ((id (name v))
        (t  (time v)))
    (let loop ((e e))
      (cond ((not (pair? (caar e)))
              #f)
            ((and (eq? id (name (caar e)))
                  (eqv? t (time (caar e))))
              (car e))
            (else
              (loop (cdr e)))))))

(define (value x e)
  (if (var? x)
      (let ((v (lookup x e)))
        (if v
            (value (cadr v) e)
            x))
      x))

(define (copy x n)
  (cond
    ((not (pair? x)) x)
    ((var? x) (append x n))
    (else
      (cons (copy (car x) n)
            (copy (cdr x) n)))))

(define (bind x y e)
  (cons (list x y) e))

(define (unify x y e)
  (let ((x (value x e))
        (y (value y e)))
    (cond
      ((eq? x y) e)
      ((var? x) (bind x y e))
      ((var? y) (bind y x e))
      ((or (not (pair? x))
           (not (pair? y))) #f)
      (else
        (let ((e* (unify (car x) (car y) e)))
          (and e* (unify (cdr x) (cdr y) e*)))))))


(define (resolve x e)
  (cond ((not (pair? x)) x)
        ((var? x)
          (let ((v (value x e)))
            (if (var? v)
                v
                (resolve v e))))
        (else
          (cons
            (resolve (car x) e)
            (resolve (cdr x) e)))))

(define (print-frame e)
  (newline)
  (let loop ((ee e))
    (cond ((pair? (cdr ee))
            (cond ((null? (time (caar ee)))
                    (display (cadaar ee))
                    (display " = ")
                    (display (resolve (caar ee) e))
                    (newline)))
            (loop (cdr ee))))))


;; Graph example from section 1

(define db
  '(((edge a b))
    ((edge a f))
    ((edge a g))
    ((edge b c))
    ((edge b d))
    ((edge c d))
    ((edge c e))
    ((edge g h))
    ((edge d h))
    ((edge h e))
    ((edge h f))

    ((path (? A) (? B) ((? A) (? B)))
     (edge (? A) (? B)))

    ((path (? A) (? B) ((? A) . (? CB)))
     (edge (? A) (? C))
     (path (? C) (? B) (? CB)))))

(define goals '((path a f (? P))))

; recursive PROVE
(prove3 goals empty 1)

; 6-slide PROVE
(prove5 '() goals db empty 1)

;; Negation as failure

(define db
  '(((some foo))
    ((some bar))
    ((some baz))

    ((eq (? X) (? X)))

    ((neq (? X) (? Y))
     (eq (? X) (? Y)) ! fail)

    ((neq (? X) (? Y)))))

(define goals '((some (? X))
                (some (? Y))
                (neq (? X) (? Y))))

; 9-slide PROVE
(prove6 '() goals db empty 1 '())


    </script>




    <script type="text/ohm-js">

// pass 1 grammar

      // An Ohm grammar for Scheme, step 1.
Scm2JSBasic {
  Program = Form+
  Form = SList | Atom
  QuotedSexp = "'" Form
  BackQuotedSexp = "`" Form
  CommaSexp = "," Form
  SList = DottedList | NullTerminatedList
  DottedList = "(" ListItem+ "." ListItem ")"
  NullTerminatedList =   "(" ListItem+ ")"
  ListItem = (Atom | SList)
  Atom = lexical_atom | Syntactic_Atom
  Syntactic_Atom = QuotedSexp | BackQuotedSexp | CommaSexp

  lexical_atom = lexical_integer | lexical_symbol | lexical_string | lexical_boolean | lexical_nullList
  lexical_nullList = "(" ")"
  lexical_boolean = "#f" | "#t"
  lexical_integer = lexical_numchar+
  lexical_numchar = "0".."9"
  lexical_string = "\"" (~"\"" any)+ "\""
  lexical_symbol = lexical_letchar (lexical_letchar | lexical_numchar)*
  lexical_letchar = lexical_lc | lexical_uc | "+" | "*" | "!" | "?"  | "_" | "-"
  lexical_lc = "a".."z"
  lexical_uc = "A".."Z"
  semiColonComment = ";" (~"\n" any)* "\n"
  space += semiColonComment
}
</script>


    <script type="text/ohm-js">

// pass 2 grammar

Scm2JSPass2 {
    Program = (GlobalVariableDefinition | GlobalFunctionDefinition | FunctionCall)+
    GlobalFunctionDefinition = BEGIN Define FunctionNameAndFormals Form+ END
    GlobalVariableDefinition = BEGIN Define Identifier Form END
    FunctionCall = ~Define "(" Identifier ListItem* END
    FunctionNameAndFormals = BEGIN Identifier ListItem* END
    Identifier = lexical_symbol
    Define = "define"
    BEGIN = "("
    END = ")"

  Form = SList | Atom
  SList = DottedList | SpecialForm | NullTerminatedList

SpecialForm = CondExpression | LetExpression | IfThenElseExpression | IfThenExpression

CondExpression = BEGIN lexical_COND CondFirstClause CondOtherClause* ElseClause* END
lexical_COND = space* "cond" space*
ElseClause = BEGIN lexical_ELSE Form+ END
lexical_ELSE = space* "else" space*
CondFirstClause = BEGIN ~lexical_ELSE TestExpr Body+ END
CondOtherClause = BEGIN ~lexical_ELSE TestExpr Body+ END
TestExpr = Form
Body = Form

LetExpression = BEGIN lexical_LET LetBindings Body+ END
lexical_LET = space* "let" "*"? space*
LetBindings = BEGIN Binding+ END
Binding = BEGIN LetVar LetClause END
LetVar = lexical_symbol
LetClause = Form

IfThenElseExpression = BEGIN lexical_IF IfTestExpr ThenPart ElsePart END
IfThenExpression = BEGIN lexical_IF IfTestExpr ThenPart END
IfTestExpr = Form
ThenPart = Form
ElsePart = Form
lexical_IF = space* "if" space*

  DottedList = "(" ListItem+ "." ListItem ")"
  NullTerminatedList =   "(" ListItem+ ")"
  ListItem = (Atom | SList)
  Atom = lexical_atom | QuotedNil
  QuotedNil = BEGIN "quote" BEGIN END END

  lexical_atom = lexical_integer | lexical_symbol | lexical_string | lexical_boolean | lexical_nullList
  lexical_nullList = "(" ")"
  lexical_boolean = "#f" | "#t"
  lexical_integer = lexical_numchar+
  lexical_numchar = "0".."9"
  lexical_string = "\"" (~"\"" any)+ "\""
  lexical_symbol = lexical_letchar (lexical_letchar | lexical_numchar)*
  lexical_letchar = lexical_lc | lexical_uc | "+" | "*" | "!" | "?"  | "_" | "-"
  lexical_lc = "a".."z"
  lexical_uc = "A".."Z"
  semiColonComment = ";" (~"\n" any)* "\n"
  space += semiColonComment
}

    </script>

    <script>

      var g_namespace = ohm.grammarsFromScriptElements();
      var pass1_grammar = g_namespace["Scm2JSBasic"];
      var pass2_grammar = g_namespace["Scm2JSPass2"];

      var tests = document.querySelectorAll('script[type="text/test"]');

      function toListOfStrings(a) {
	  return a.join(' ');
      }
      
      function toPackedString(a) {
	  return a.join('');
      }
      

// pass1 semantics

      var pass1_semantics = pass1_grammar.createSemantics();
      
      pass1_semantics.addOperation(
	  'unity',
	  {
	      Program: function(tree) {return toListOfStrings(tree.unity())},
	      Form: function(item) {return item.unity()},
	      QuotedSexp: function(_, form) {return "'" + form.unity()},
	      BackQuotedSexp: function(_, form) {return "`" + form.unity()},
	      CommaSexp: function(_, form) {return "," + form.unity()},
	      SList: function(lis) {return lis.unity()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toListOfStrings(items.unity()) + " . " + lastItem.unity() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toListOfStrings(items.unity()) + ")"},
	      ListItem: function(item) {return item.unity()},
	      Atom: function(a) {return a.unity()},
	      lexical_integer: function(ns) {return toPackedString(ns.unity());},
	      lexical_symbol: function(c, cs) {return c.unity() + toPackedString(cs.unity());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unity()) + "\""},
	      lexical_letchar: function(c) {return c.unity()},
	      lexical_numchar: function(c) {return c.unity()},
	      lexical_lc: function(c) {return c.unity()},
	      lexical_uc: function(c) {return c.unity()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      

          pass1_semantics.addOperation(
	  'unquote',
	  {
	      Program: function(tree) {return toListOfStrings(tree.unquote())},
	      Form: function(item) {return item.unquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.unquote() + ")"},
	      BackQuotedSexp: function(_, form) {return "`" + form.unquote()},
	      CommaSexp: function(_, form) {return "," + form.unquote()},
	      SList: function(lis) {return lis.unquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toListOfStrings(items.unquote()) + " . " + lastItem.unquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toListOfStrings(items.unquote()) + ")"},
	      ListItem: function(item) {return item.unquote()},
	      Atom: function(a) {return a.unquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.unquote());},
	      lexical_symbol: function(c, cs) {return c.unquote() + toPackedString(cs.unquote());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unquote()) + "\""},
	      lexical_letchar: function(c) {return c.unquote()},
	      lexical_numchar: function(c) {return c.unquote()},
	      lexical_lc: function(c) {return c.unquote()},
	      lexical_uc: function(c) {return c.unquote()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );



          pass1_semantics.addOperation(
	  'unbackquote',
	  {
	      Program: function(tree) {return toListOfStrings(tree.unbackquote())},
	      Form: function(item) {return item.unbackquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.unbackquote() + ")"},
	      BackQuotedSexp: function(_, form) {return form.inbackquote();},
	      CommaSexp: function(_, form) {throw "can\'t happen - comma not inside backquote - (actually, not necessarily the case, but nested backquotes left as an exercise for the reader)"},
	      SList: function(lis) {return lis.unbackquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toListOfStrings(items.unbackquote()) + " . " + lastItem.unbackquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toListOfStrings(items.unbackquote()) + ")"},
	      ListItem: function(item) {return item.unbackquote()},
	      Atom: function(a) {return a.unbackquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.unbackquote());},
	      lexical_symbol: function(c, cs) {return c.unbackquote() + toPackedString(cs.unbackquote());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unbackquote()) + "\""},
	      lexical_letchar: function(c) {return c.unbackquote()},
	      lexical_numchar: function(c) {return c.unbackquote()},
	      lexical_lc: function(c) {return c.unbackquote()},
	      lexical_uc: function(c) {return c.unbackquote()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      
          pass1_semantics.addOperation(
	  'inbackquote',
	  {
	      Program: function(tree) {throw "can\'t happen"},
	      Form: function(item) {return item.inbackquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.inbackquote() + ")"},
	      BackQuotedSexp: function(_, form) {throw "can\'t happen - left as exercise to the reader";},
	      CommaSexp: function(_, form) {return form.unity()}, // use unbackquote to get eval'ed value
	      SList: function(lis) {return lis.inbackquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(list " + toListOfStrings(items.inbackquote()) + " . " + lastItem.inbackquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(list " + toListOfStrings(items.inbackquote()) + ")"},
	      ListItem: function(item) {return item.inbackquote()},
	      Atom: function(a) {return a.inbackquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.inbackquote());},
	      lexical_symbol: function(c, cs) {return "(quote " + c.inbackquote() + toPackedString(cs.inbackquote()) + ")";},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.inbackquote()) + "\""},
	      lexical_letchar: function(c) {return c.inbackquote()},
	      lexical_numchar: function(c) {return c.inbackquote()},
	      lexical_lc: function(c) {return c.inbackquote()},
	      lexical_uc: function(c) {return c.inbackquote()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      
////////


// pass 2 semantics
      var pass2_semantics = pass2_grammar.createSemantics();
      
      pass2_semantics.addOperation(
	  'unity',
	  {
	      Program: function(listOfForms) {return toListOfStrings(listOfForms.unity())},
              GlobalVariableDefinition: function(_begin,_define,id,form,_end) {return "var " + id.unity() + " = " + form.unity() + ";";},
              GlobalFunctionDefinition: function(_begin,_define,nf,body,_end) {return nf.unity() + " { return " + body.unity() + "; };";},
              FunctionCall: function(_lp,id,actuals,_end) {return "call " + id.unity() + "(" + actuals.unity() + ");";},
              FunctionNameAndFormals: function(_begin,id,formals,_end) {return "function " + id.unity() + "(" + formals.unity() + ")";},
              Identifier: function(id) {return id.unity();},
              Define: function(_define) {return "";},
              END: function(_rp) {return "";},
     
              Form: function(item) {return item.unity()},
	      SList: function(lis) {return lis.unity()},

              SpecialForm: function(e) { return e.unity(); },
              CondExpression: function(_begin,c,firstClause,otherClauses,elseClause,_end) { 
                  return "COND: " + c.unity() + " " + firstClause.unity() + otherClauses.unity() + elseClause.unity() + " END COND"; },
              lexical_COND: function(_sp1,_,_sp2) {return "";},
              ElseClause: function(_begin,_else,forms,_end) { return "CELSE: " + forms.unity(); },
              lexical_ELSE: function(_1,_else,_2) { return ""; },
              CondFirstClause: function(_begin,etest,body,_end) { return "cif (" + etest.unity() + ") { return " + body.unity() + "; })"; },
              CondOtherClause: function(_begin,etest,body,_end) { return " celseif (" + etest.unity() + ") { return " + body.unity() + "; })"; },
              TestExpr: function(form) { return form.unity(); },
              Body: function(form) { return form.unity(); },

              LetExpression: function(_begin, _let, bindings, body, _end) { return "LET " + bindings.unity() + " IN " + body.unity() + "; END LET"; },
              lexical_LET: function(_sp1,_let,_star,_sp2) { return ""; },
              LetBindings: function(_begin,bindings,_end) { return bindings.unity(); },
              Binding: function(_begin,v,e,_end) { return "let " + v.unity() + " = " + e.unity() + ";" },
              LetVar: function(id) {return id.unity(); },
              LetClause: function(e) { return e.unity(); },

              IfThenElseExpression: function(_begin,_if,e,thenPart,elsePart,_end) {return "IF " + e.unity() + " THEN { return " + thenPart.unity() + ";} ELSE { return " + elsePart.unity() + ";} END IF";},
              IfThenExpression: function(_begin,_if,e,thenPart,_end) {return "IF " + e.unity() + " THEN {return " + thenPart.unity() + "; END IF";},
              IfTestExpr: function(e) { return e.unity(); },
              ThenPart: function(f) { return f.unity(); },
              ElsePart: function(f) { return f.unity(); },
              lexical_IF: function(_sp1,_if,_sp2) { return ""; },

	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toListOfStrings(items.unity()) + " . " + lastItem.unity() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toListOfStrings(items.unity()) + ")"},
	      ListItem: function(item) {return item.unity()},
	      Atom: function(a) {return a.unity()},
              QuotedNil: function(_begin, _q, _begin2, _end2, _end) { return "((new List()))"; },

	      lexical_integer: function(ns) {return toPackedString(ns.unity());},
	      lexical_symbol: function(c, cs) {return c.unity() + toPackedString(cs.unity());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unity()) + "\""},
	      lexical_letchar: function(c) {return c.unity()},
	      lexical_numchar: function(c) {return c.unity()},
	      lexical_lc: function(c) {return c.unity()},
	      lexical_uc: function(c) {return c.unity()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return ("#f" == this.sourceString) ? "false" : "true" },
	      _terminal: function() { return this.primitiveValue; }
	  }
      );

////////

      var resultsString = '';
      
      function displayDate () {
	  document.getElementById('timestamp').innerHTML = Date();
      }

      function doPipeline(testElement) {
	  var testString = testElement.innerHTML;
          var parsed_pass1 = pass1_grammar.match(testString);
          var transpiled_pass1 = parsed_pass1.failed() ? "" : pass1_semantics(parsed_pass1).unbackquote();
	  var parsed_pass2 = pass2_grammar.match(transpiled_pass1);
	  var tail = "...";
	  var charsToDisplay = 40;
	  if (transpiled_pass1.length < charsToDisplay) {
	      tail = "";
	  }
	  if (parsed_pass1.failed()) {
             resultsString = resultsString + "<br>" + "pass1 parse failed " + transpiled_pass1.substring(0,charsToDisplay);
          } else if (parsed_pass2.failed()) {
             resultsString = resultsString + "<br>" + "pass2 parse failed " + transpiled_pass1.substring(0,charsToDisplay);
          } else {
             var transpiled_pass2 = pass2_semantics(parsed_pass2).unity();
             resultsString = resultsString + "<br>" + " " + transpiled_pass1.substring(0,charsToDisplay) + tail + " <--- <br>" + transpiled_pass2;
          }
      }

      function displayTestResults(s,el) {
	  document.getElementById(el).innerHTML = s;
      }

      function displayStringsEqual(s1,s2,el) {
          document.getElementById(el).innerHTML = (s1 == s2);
      }
      
      function pipelinetest() {
	  resultsString = '';
	  tests.forEach(doPipeline);
	  displayTestResults(resultsString,'input');
	  displayDate();
      }

</script>






  </head>
  <body>
    <button onclick="pipelinetest()">Click me (pass1&2 test)</button>
    <p id="timestamp"></p>
    <p id="bool"></p>
    <p id="input"></p>
    <p id="secondResult"></p>
  </body>
</html>
