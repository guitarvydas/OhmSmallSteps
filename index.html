<!doctype html>
<html>
  <head>
    <title>ohm/js in small steps</title>
    <meta charset=utf-8>
    <script src="/Users/tarvydas/projects/ohm/examples/lib.js"></script>
    <script src="/Users/tarvydas/projects/ohm/dist/ohm.js"></script>
    <script type="text/ohm-js">

      // An Ohm grammar for Scheme, step 1.
Scm2JSBasic {
  Program = Form+
  Form = SList | Atom
  QuotedSexp = "'" Form
  BackQuotedSexp = "`" Form
  CommaSexp = "," Form
  SList = DottedList | NullTerminatedList
  DottedList = "(" ListItem+ "." ListItem ")"
  NullTerminatedList =   "(" ListItem+ ")"
  ListItem = (Atom | SList)
  Atom = lexical_atom | Syntactic_Atom
  Syntactic_Atom = QuotedSexp | BackQuotedSexp | CommaSexp

  lexical_atom = lexical_integer | lexical_symbol | lexical_string | lexical_boolean | lexical_nullList
  lexical_nullList = "(" ")"
  lexical_boolean = "#f" | "#t"
  lexical_integer = lexical_numchar+
  lexical_numchar = "0".."9"
  lexical_string = "\"" (~"\"" any)+ "\""
  lexical_symbol = lexical_letchar (lexical_letchar | lexical_numchar)*
  lexical_letchar = lexical_lc | lexical_uc | "+" | "*" | "!" | "?"  | "_" | "-"
  lexical_lc = "a".."z"
  lexical_uc = "A".."Z"
  semiColonComment = ";" (~"\n" any)* "\n"
  space += semiColonComment
}
    </script>

    <script>
      var g = ohm.grammarFromScriptElement();
    </script>

    <script type="text/test">
      (#t #f)
    </script>
    
    <script type="text/test">
      ( #t #f . #t)
    </script>
    
    <script type="text/test">
      ( . #t)
    </script>
    
    <script type="text/test">
      asymbol
    </script>
    
    <script type="text/test">
      (asymbol)
    </script>

    <script type="text/test">
      (asymbol1 asymbol2)
    </script>

    <script type="text/test">
      (asymbol1 asymbol2)
      (asymbol3 asymbol4)
    </script>

    <script type="text/test">
      'asymbol5
    </script>

    <script type="text/test">
      ('(asymbol6 asymbol7))
    </script>

    <script type="text/test">
      `a
    </script>

    <script type="text/test">
      `,b
    </script>

    <script type="text/test">
      `(c)
    </script>
    <script type="text/test">
      `(d e f)
    </script>
    <script type="text/test">
      `(g ,h i)
    </script>

    <script type="text/test">
(define (try g r e n)
  (if (null? r)
      #f
      (let* ((a  (copy (car r) (list n)))
             (ne (unify (car g) (car a) e)))
        (if ne
            (prove3 (append (cdr a) (cdr g)) ne (+ 1 n)))
        (try g (cdr r) e n))))

(define (prove3 g e n)
  (cond ((null? g)
          (print-frame e))
        (else
          (try g db e n))))


(define link list)
(define L_l car)
(define L_g cadr)
(define L_r caddr)
(define L_e cadddr)
(define (L_n x) (car (cddddr x)))


(define (back5 l g r e n)
  (if (and (pair? g)
           (pair? r))
      (prove5 l g (cdr r) e n)
      (prove5 (L_l l)
              (L_g l)
              (cdr (L_r l))
              (L_e l)
              (L_n l))))


(define (prove5 l g r e n)
  (cond
    ((null? g)
      (print-frame e)
      (back5 l g r e n))
    ((null? r)
      (if (null? l)
          #t
          (back5 l g r e n)))
    (else
      (let* ((a  (copy (car r) n))
             (e* (unify (car a) (car g) e)))
        (if e*
            (prove5 (link l g r e n)
                    (append (cdr a) (cdr g))
                    db
                    e*
                    (+ 1 n))
            (back5 l g r e n))))))


(define (L_c x) (cadr (cddddr x)))


(define (clear_r x)
  (set-car! (cddr x) '(())))


(define (back6 l g r e n c)
  (cond
    ((and (pair? g)
          (pair? r))
      (prove6 l g (cdr r) e n c))
    ((pair? l)
      (prove6 (L_l l)
              (L_g l)
              (cdr (L_r l))
              (L_e l)
              (L_n l)
              (L_c l)))))


(define (prove6 l g r e n c)
  (cond
    ((null? g)
      (print-frame e)
      (back6 l g r e n c))
    ((eq? '! (car g))
      (clear_r c)
      (prove6 c (cdr g) r e n c))
    ((eq? 'r! (car g))
      (prove6 l (cddr g) r e n (cadr g)))
    ((null? r)
      (if (null? l)
          #t
          (back6 l g r e n c)))
    (else
      (let* ((a  (copy (car r) n))
             (e* (unify (car a) (car g) e)))
        (if e*
            (prove6 (link l g r e n c)
                    (append (cdr a) `(r! ,l) (cdr g))
                    db
                    e*
                    (+ 1 n)
                    l)
            (back6 l g r e n c))))))


(define empty '((bottom)))

(define var '?)
(define name cadr)
(define time cddr)

(define (var? x)
  (and (pair? x)
       (eq? var (car x))))

(define (lookup v e)
  (let ((id (name v))
        (t  (time v)))
    (let loop ((e e))
      (cond ((not (pair? (caar e)))
              #f)
            ((and (eq? id (name (caar e)))
                  (eqv? t (time (caar e))))
              (car e))
            (else
              (loop (cdr e)))))))

(define (value x e)
  (if (var? x)
      (let ((v (lookup x e)))
        (if v
            (value (cadr v) e)
            x))
      x))

(define (copy x n)
  (cond
    ((not (pair? x)) x)
    ((var? x) (append x n))
    (else
      (cons (copy (car x) n)
            (copy (cdr x) n)))))

(define (bind x y e)
  (cons (list x y) e))

(define (unify x y e)
  (let ((x (value x e))
        (y (value y e)))
    (cond
      ((eq? x y) e)
      ((var? x) (bind x y e))
      ((var? y) (bind y x e))
      ((or (not (pair? x))
           (not (pair? y))) #f)
      (else
        (let ((e* (unify (car x) (car y) e)))
          (and e* (unify (cdr x) (cdr y) e*)))))))


(define (resolve x e)
  (cond ((not (pair? x)) x)
        ((var? x)
          (let ((v (value x e)))
            (if (var? v)
                v
                (resolve v e))))
        (else
          (cons
            (resolve (car x) e)
            (resolve (cdr x) e)))))

(define (print-frame e)
  (newline)
  (let loop ((ee e))
    (cond ((pair? (cdr ee))
            (cond ((null? (time (caar ee)))
                    (display (cadaar ee))
                    (display " = ")
                    (display (resolve (caar ee) e))
                    (newline)))
            (loop (cdr ee))))))


;; Graph example from section 1

(define db
  '(((edge a b))
    ((edge a f))
    ((edge a g))
    ((edge b c))
    ((edge b d))
    ((edge c d))
    ((edge c e))
    ((edge g h))
    ((edge d h))
    ((edge h e))
    ((edge h f))

    ((path (? A) (? B) ((? A) (? B)))
     (edge (? A) (? B)))

    ((path (? A) (? B) ((? A) . (? CB)))
     (edge (? A) (? C))
     (path (? C) (? B) (? CB)))))

(define goals '((path a f (? P))))

; recursive PROVE
(prove3 goals empty 1)

; 6-slide PROVE
(prove5 '() goals db empty 1)

;; Negation as failure

(define db
  '(((some foo))
    ((some bar))
    ((some baz))

    ((eq (? X) (? X)))

    ((neq (? X) (? Y))
     (eq (? X) (? Y)) ! fail)

    ((neq (? X) (? Y)))))

(define goals '((some (? X))
                (some (? Y))
                (neq (? X) (? Y))))

; 9-slide PROVE
(prove6 '() goals db empty 1 '())


    </script>


    <script>

      var sem = g.createSemantics();
      
      function toListOfStrings(a) {
	  return a.join(' ');
      }
      
      function toPackedString(a) {
	  return a.join('');
      }
      
      sem.addOperation(
	  'unity',
	  {
	      Program: function(tree) {return toListOfStrings(tree.unity())},
	      Form: function(item) {return item.unity()},
	      QuotedSexp: function(_, form) {return "'" + form.unity()},
	      BackQuotedSexp: function(_, form) {return "`" + form.unity()},
	      CommaSexp: function(_, form) {return "," + form.unity()},
	      SList: function(lis) {return lis.unity()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toListOfStrings(items.unity()) + " . " + lastItem.unity() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toListOfStrings(items.unity()) + ")"},
	      ListItem: function(item) {return item.unity()},
	      Atom: function(a) {return a.unity()},
	      lexical_integer: function(ns) {return toPackedString(ns.unity());},
	      lexical_symbol: function(c, cs) {return c.unity() + toPackedString(cs.unity());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unity()) + "\""},
	      lexical_letchar: function(c) {return c.unity()},
	      lexical_numchar: function(c) {return c.unity()},
	      lexical_lc: function(c) {return c.unity()},
	      lexical_uc: function(c) {return c.unity()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      

          sem.addOperation(
	  'unquote',
	  {
	      Program: function(tree) {return toListOfStrings(tree.unquote())},
	      Form: function(item) {return item.unquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.unquote() + ")"},
	      BackQuotedSexp: function(_, form) {return "`" + form.unquote()},
	      CommaSexp: function(_, form) {return "," + form.unquote()},
	      SList: function(lis) {return lis.unquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toListOfStrings(items.unquote()) + " . " + lastItem.unquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toListOfStrings(items.unquote()) + ")"},
	      ListItem: function(item) {return item.unquote()},
	      Atom: function(a) {return a.unquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.unquote());},
	      lexical_symbol: function(c, cs) {return c.unquote() + toPackedString(cs.unquote());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unquote()) + "\""},
	      lexical_letchar: function(c) {return c.unquote()},
	      lexical_numchar: function(c) {return c.unquote()},
	      lexical_lc: function(c) {return c.unquote()},
	      lexical_uc: function(c) {return c.unquote()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );



          sem.addOperation(
	  'unbackquote',
	  {
	      Program: function(tree) {return toListOfStrings(tree.unbackquote())},
	      Form: function(item) {return item.unbackquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.unbackquote() + ")"},
	      BackQuotedSexp: function(_, form) {return form.inbackquote();},
	      CommaSexp: function(_, form) {throw "can\'t happen - comma not inside backquote - (actually, not necessarily the case, but nested backquotes left as an exercise for the reader)"},
	      SList: function(lis) {return lis.unbackquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(" + toListOfStrings(items.unbackquote()) + " . " + lastItem.unbackquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(" + toListOfStrings(items.unbackquote()) + ")"},
	      ListItem: function(item) {return item.unbackquote()},
	      Atom: function(a) {return a.unbackquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.unbackquote());},
	      lexical_symbol: function(c, cs) {return c.unbackquote() + toPackedString(cs.unbackquote());},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.unbackquote()) + "\""},
	      lexical_letchar: function(c) {return c.unbackquote()},
	      lexical_numchar: function(c) {return c.unbackquote()},
	      lexical_lc: function(c) {return c.unbackquote()},
	      lexical_uc: function(c) {return c.unbackquote()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      
          sem.addOperation(
	  'inbackquote',
	  {
	      Program: function(tree) {throw "can\'t happen"},
	      Form: function(item) {return item.inbackquote()},
	      QuotedSexp: function(_, form) {return "(quote " + form.inbackquote() + ")"},
	      BackQuotedSexp: function(_, form) {throw "can\'t happen - left as exercise to the reader";},
	      CommaSexp: function(_, form) {return form.unity()}, // use unbackquote to get eval'ed value
	      SList: function(lis) {return lis.inbackquote()},
	      DottedList: function(_lp, items, _dot, lastItem, _rp) {
		  return "(list " + toListOfStrings(items.inbackquote()) + " . " + lastItem.inbackquote() + ")"},
	      NullTerminatedList: function(_lp, items, _rp) {
		  return "(list " + toListOfStrings(items.inbackquote()) + ")"},
	      ListItem: function(item) {return item.inbackquote()},
	      Atom: function(a) {return a.inbackquote()},
	      lexical_integer: function(ns) {return toPackedString(ns.inbackquote());},
	      lexical_symbol: function(c, cs) {return "(quote " + c.inbackquote() + toPackedString(cs.inbackquote()) + ")";},
	      lexical_string: function(_q1, chars, _q2) {return "\"" + toPackedString(chars.inbackquote()) + "\""},
	      lexical_letchar: function(c) {return c.inbackquote()},
	      lexical_numchar: function(c) {return c.inbackquote()},
	      lexical_lc: function(c) {return c.inbackquote()},
	      lexical_uc: function(c) {return c.inbackquote()},

	      lexical_nullList: function(_lp,_rp) {return "()"},
	      lexical_boolean: function(b) {return this.sourceString},
	      _terminal: function() { return this.primitiveValue; }
	  }
      );
      
</script>



    <script>
      var tests = document.querySelectorAll('script[type="text/test"]');
    </script>

  </head>
  <body>
    <button onclick="pipelinetest()">Click me (pipeline test)</button>
    <p id="timestamp"></p>
    <p id="bool"></p>
    <p id="input"></p>
    <p id="secondResult"></p>
    <script>
      var resultsString = '';
      
      function displayDate () {
	  document.getElementById('timestamp').innerHTML = Date();
      }
      function do1Test(testElement) {
	  var testString = testElement.innerHTML;
	  var r = g.match(testString);
	  var tail = "...";
	  var charsToDisplay = 40;
	  if (testString.length < charsToDisplay) {
	      tail = "";
	  }
	  resultsString = resultsString + "<br>" + r.toString() + " " + testString.substring(0,charsToDisplay) + tail + (r.succeeded() ? (" <--- " + sem(r).unbackquote()) : '');
      }
      function doRegressionTest(testElement) {
	  var testString = testElement.innerHTML;
	  var r = g.match(testString);
          var filtered = r.failed() ? "" : sem(r).unbackquote();
	  var rregression = g.match(filtered);
	  var tail = "...";
	  var charsToDisplay = 40;
	  if (testString.length < charsToDisplay) {
	      tail = "";
	  }
	  if (r.failed()) {
             resultsString = resultsString + "<br>" + "r failed " + testString.substring(0,charsToDisplay);
          } else if (rregression.failed()) {
             resultsString = resultsString + "<br>" + "rregression failed " + testString.substring(0,charsToDisplay);
          } else if (filtered == sem(rregression).unbackquote()) {
             resultsString = resultsString + "<br>" + "regression ok " + sem(rregression).unbackquote();
          } else {
             resultsString = resultsString + "<br>" + "regression FAILED";
          }
      }
      function displayTestResults(s,el) {
	  document.getElementById(el).innerHTML = s;
      }
      function displayStringsEqual(s1,s2,el) {
          document.getElementById(el).innerHTML = (s1 == s2);
      }
      function ohmtest () {
	  resultsString = '';
	  console.log(tests);
	  console.log(tests[0]);
	  tests.forEach(do1Test);
	  displayTestResults(resultsString,'input');
	  displayDate();
      }
      //ohmtest();
      
      function pipelinetest() {
	  resultsString = '';
	  tests.forEach(doRegressionTest);
          var expandedString = resultsString;
	  displayTestResults(resultsString,'input');
	  displayDate();
      }
      //pipelinetest();
    </script>
  </body>
</html>
