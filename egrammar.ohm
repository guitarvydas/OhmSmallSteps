Scm2JSegrammar {
    Program = (GlobalVariableDefinition | GlobalFunctionDefinition | TopLevelFunctionCall)+
  Form = SList | Atom
  QuotedSexp = "'" Form
  BackQuotedSexp = "`" Form
  CommaSexp = "," Form
  DottedList = "(" ListItem+ "." ListItem ")"
  NullTerminatedList =   "(" ListItem* ")"
  ListItem = (Atom | SList)
  Atom = lexical_atom | Syntactic_Atom
  Syntactic_Atom = QuotedSexp | BackQuotedSexp | CommaSexp

  lexical_atom = lexical_integer | lexical_symbol | lexical_string | lexical_boolean
  lexical_boolean = "#f" | "#t"
  lexical_integer = lexical_numchar+
  lexical_numchar = "0".."9"
  lexical_string = "\"" (~"\"" any)+ "\""
  lexical_symbol = lexical_letchar (lexical_letchar | lexical_numchar)*
  lexical_letchar = lexical_lc | lexical_uc | "+" | "*" | "!" | "?"  | "_" | "-"
  lexical_lc = "a".."z"
  lexical_uc = "A".."Z"
  semiColonComment = ";" (~"\n" any)* "\n"
  space += semiColonComment

Arg = AtomicArg | NonAtomicArg
AtomicArg = ListItem
NonAtomicArg = ListItem

  SList =   BEGIN lexical_AtNewListAt ListItem* END -- atnewlistat
           | SpecialForm 
           | FunctionCall
           | NullTerminatedList
           | DottedList 

SpecialForm = QuotedExpression | CondExpression | LetExpression | IfThenElseExpression | IfThenExpression | AndExpression | OrExpression | NotExpression

CondExpression = CondExpressionWithElse | CondExpressionWithoutElse
CondExpressionWithElse = BEGIN lexical_COND CondClause+ CondElseClause END
CondExpressionWithoutElse = BEGIN lexical_COND CondClause+ END
CondClause = BEGIN ~lexical_ELSE ClauseBody+ END
CondElseClause = BEGIN lexical_ELSE Form+ END
ClauseBody = Form

LetExpression = BEGIN (lexical_LETSTAR | lexical_LET) LetBindings LetBody END
LetBindings = BEGIN Binding+ END
Binding = BEGIN LetVar LetBindingClause END
LetVar = lexical_symbol
LetBindingClause = Form
LetBody = Form

IfThenElseExpression = BEGIN lexical_IF IfTestExpr ThenPart ElsePart END
IfThenExpression = BEGIN lexical_IF IfTestExpr ThenPart END
IfTestExpr = Form
ThenPart = Form
ElsePart = Form

AndExpression = BEGIN lexical_AND Boolean+ END
OrExpression = BEGIN lexical_OR Boolean+ END
NotExpression = BEGIN lexical_NOT Boolean END
    Boolean = Form

    QuotedExpression = QuotedSymbol | QuotedOther
    QuotedSymbol = BEGIN lexical_QUOTE lexical_symbol END
    QuotedOther = BEGIN lexical_QUOTE (lexical_integer | lexical_string | lexical_boolean) END

    GlobalFunctionDefinition = BEGIN lexical_DEFINE FunctionNameAndFormals Form+ END
    GlobalVariableDefinition = BEGIN lexical_DEFINE Identifier Form END
    TopLevelFunctionCall = FunctionCall
    FunctionCall = BEGIN Identifier Arg* END
    FunctionNameAndFormals = BEGIN Identifier Identifier* END
    Identifier = ~Keyword lexical_symbol
    BEGIN = "("
    END = ")"

Keyword =   lexical_DEFINE
          | lexical_COND 
          | lexical_IF
          | lexical_LET
          | lexical_LETSTAR
          | lexical_AtNewListAt 
          | lexical_AND | lexical_OR | lexical_NOT
          | lexical_ELSE
          | lexical_QUOTE

lexical_AND = "and" ~alnum space*
lexical_OR = "or" ~alnum space*
lexical_NOT = "not" ~alnum space*
lexical_AtNewListAt = "@newList@" ~alnum space*
lexical_DEFINE = "define" ~alnum space*
lexical_IF = "if" ~alnum space*
lexical_COND = "cond" ~alnum space*
lexical_ELSE = "else" ~alnum space*
lexical_LETSTAR = "let*" ~alnum space*
lexical_LET = "let" ~alnum space*
lexical_QUOTE = "quote" ~alnum space*
}
